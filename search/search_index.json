{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about","title":"About","text":"<p>This is a personal documentation about ARM. The information is mostly taken from the ARM Developer Documentation, but other sources are used as well. The documentation is built with MkDocs Material and deployed on GitHub Pages.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Navigating a large field of study can be cumbersome at times. Having valuable information in one place that is easily navigatable makes things easier. This documentation is for the work I do and tailored to this specific use case. I made it public because others may be able to benefit from this documentation as well.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>The ARM Architecture is integrated into a range of technologies, ranging from SoC devices (like smartphones), microcomputers, embedded devices, servers and even supercomputers. ARM exposes a common ISA &amp; worflow to help with interoperability across different implementations of the architecture.</p>"},{"location":"introduction/#architectures","title":"Architectures","text":"<p>This section provides general information about what an architecture is, what subdivisions of it exist, and how all of this is connected.</p>"},{"location":"introduction/#what-actually-is-an-architecture","title":"What Actually Is an Architecture?","text":"<p>Definition: Architecture</p> <p>~ is a functional specification. In case of the Arm architecture, it's the functional specification of a processor. It specifies how a processor will behave, i.e. what instructions it has and what the instructions do. It is a contract between hardware and software, specifying what functionality software can rely on the hardware to provide. Some features are optional, see this subsection.</p> <p>The architecture specifies</p> <ol> <li>the instruction set: the function of each instruction &amp; how instructions are represented in memory (encoding)</li> <li>the register set: how many, sizes, functions &amp; initial state</li> <li>the exception model: different levels of privilege, types of exceptions &amp; what happens when taking and returning from exceptions</li> <li>the memory model: memory (access) ordering &amp; cache behavior (when software must perform explicit maintenance)</li> <li>debug, trace &amp; profiling: setting and triggering breakpoints &amp; what info can be captured by trace tools and in what format</li> </ol>"},{"location":"introduction/#system-architecture","title":"System Architecture","text":"<p>Systems include more that just a processor core. ARM provides specifications to describe requirements for systems containing a processor.</p> <p></p> <p>Specifications are the basis of software compatibility. The system architecture consists of</p> <ol> <li>Component Architecture Specification<ul> <li>first layer providing a common programmer's model (i.e. common instruction set &amp; workflow) to software through ISA compatibility</li> </ul> </li> <li>System Architecture, containing<ol> <li>Base System Architecture (BSA)<ul> <li>describes a hardware system architecture that system software can rely on</li> <li>covers aspects of processor and system architecture, e.g. interrupt controller, timers, other common devices</li> <li>provides reliable platform for standard OSs, hypervisors &amp; firmware</li> <li>applicable across different markets and use cases</li> <li>other standards can build on BSA to provide market-specific standardization</li> </ul> </li> <li>Base Boot Requirements (BBR)<ul> <li>establishes firmware interface requirements, e.g. PSCI, SMCCC, UEFI, ACPI, SMBIOS</li> <li>covers requirements for systems based on the Arm architecture and that operating systems and hypervisors can rely on</li> <li>provides the recipes for targeting specific use cases (point 3)</li> </ul> </li> <li>xBSA, e.g. SBSA<ul> <li>supplement to the BSA that targets servers</li> <li>describes the hardware and feature requirements for a server OS</li> <li>ensures that operating systems, hypervisors and firmware operate correctly</li> </ul> </li> </ol> </li> </ol> <p>BBR also provides the recipes for targeting specific use cases</p> <ol> <li>SBBR: Specifying UEFI, ACPI, and SMBIOS requirements to boot generic, off-the-shelf operating systems and hypervisors</li> <li>EBBR: Specifying, along with the EBBR specification, UEFI requirements to boot generic, off-the-shelf operating systems</li> <li>LBRR: ...</li> </ol>"},{"location":"introduction/#architecture-vs-microarchitecture","title":"Architecture vs. Microarchitecture","text":"<p>The architecture does not tell how a processor is built or how it works. The build and design is referred to as micro-architecture.</p> <p>Definition: Micro-Architecture</p> <p>~ tells you how a particular processor works. It includes pipeline length and layout, the number and sizes of caches, cycle counts for individual instructions &amp; which optional features are implemented.</p>"},{"location":"introduction/#profiles","title":"Profiles","text":"<p>Profiles allow tailoring an architecture to different use cases while sharing several base features. There are three profiles:</p> <ol> <li>A (Application): high-performance | complex (operating) systems</li> <li>R (Real-Time): common in infrastructure with real-time demands | networking &amp; embedded devices</li> <li>M (Microcontroller): small but highly power efficient | IoT devices</li> </ol>"},{"location":"introduction/#extensions","title":"Extensions","text":"<p>Development of major versions of the Arm architecture can take many years. Because the architecture needs to evolve between major versions to add new features, minor versions, called extensions, are added. There is now an annual release of a extension. The Arm Architecture Reference Manual provides information on which features are optional or mandatory in different versions of the Armv8.x-A and Armv9.x-A architectures. There is a list on the ARM Developer Documentation that lists the most important extensions for ARMv8.x and ARMv9.x.</p> Architecture, ISA, Version, Revision/Extension &amp; More <p>When using the term ARMv9.2-A, you imply that your are talking about</p> <ol> <li>the Arm architecture</li> <li>version 9</li> <li>revision/extension 2</li> <li>with profile A (Application)</li> <li>that has the instruction set A64 (64bit)</li> </ol>"},{"location":"introduction/#other-architectures","title":"Other Architectures","text":"<p>The Arm architecture is the best known, but not the only one! Similar specifications for other components on SoCs include</p> <ol> <li>GIC: Generic Interrupt Controller</li> <li>SMMU (sometimes IOMMU): System Memory Management Unit</li> <li>Generic Timer</li> <li>AMBA: Advanced Microcontroller Bus Architecture</li> </ol>"},{"location":"introduction/#development-an-example","title":"Development &amp; An Example","text":"<p>ARMv8.2-A is version 8 of the Arm architecture, profile A, revision 2 - for short, v8.2-A. v9-A builds on v8-A &amp; adds Scalable Vector Extensions version 2 (SVE2), Transactional Memory Extensions (TME), etc. Some of the features that were optional in Armv8-A are mandatory in ARMv9-A. Updates to the architecture are published annually, adding new instructions and features: v9.0-A aligns with v8.6-A, inheriting all features + adding new features.</p>"},{"location":"introduction/#privilege-state-exceptions","title":"Privilege, State &amp; Exceptions","text":"<p>This section introduces the exception and privilege model. Modern software is developed to be split into different modules, each with a different level of access to system and processor resources. The Arm architectures enable this split by implementing different levels of privilege.</p>"},{"location":"introduction/#exception-levels-els-exception-model","title":"Exception Levels (ELs) &amp; Exception Model","text":"<p>There exist four ELs:</p> <ol> <li>EL0 - least privilege, called \"unprivileged execution\"</li> <li>EL1</li> <li>EL2 - provides support for processor virtualization</li> <li>EL3 - provides support for two security states</li> </ol> <p>Execution can move between ELs only on taking an exception, or on returning from an exception! On taking an exception, the EL either increases or remains the same. The EL cannot decrease on taking an exception. On returning from an exception, the EL either decreases or remains the same. The EL cannot increase on returning from an exception. The target EL is either implicit or defined by system registers; EL0 cannot be a target EL.</p>"},{"location":"introduction/#types-of-privilege-registers","title":"Types of Privilege &amp; Registers","text":"<p>There are two types of privilege relevant to the AArch64 (see Execution States later) exception model:</p> <ol> <li>Privilege in the memory system</li> <li>Privilege from the point of view of accessing processor resources</li> </ol> <p>Both types of privilege are affected by the current privileged EL.</p> <p>In the Arm architecture, registers are split into two main categories:</p> <ol> <li>Registers that provide system control or status reporting</li> <li>Registers that are used in instruction processing, for example to accumulate a result, and in handling exceptions</li> </ol> <p>Configuration settings for AArch64 processors are held in a series of registers known as System Registers. The combination of settings in the System registers defines the current processor context.</p>"},{"location":"introduction/#security-states","title":"Security States","text":"<p>There can be two security states:</p> <ol> <li>Secure State<ol> <li>access both Secure and the Non-secure memory address space</li> <li>at EL3, access all the system control resources</li> </ol> </li> <li>Non-Secure State<ol> <li>access only Non-secure memory address space</li> <li>cannot access the Secure system control resources</li> </ol> </li> </ol>"},{"location":"introduction/#execution-states","title":"Execution States","text":"<p>Definition: Execution State</p> <p>~ defines the standard width of the general-purpose register and the available instruction sets. It also affects aspects of the memory model, execution model,  virtual memory system architecture (VMSA) and how exceptions are managed (exception model).</p> <p>On ARMv8 and ARMv9, two execution states are supported:</p> <ol> <li>AArch64<ul> <li>features 31 64-bit general-purpose registers, with a 64-bit Program Counter (PC), Stack Pointer (SP), and Exception Link Registers (ELRs)</li> <li>provides a single instruction set: A64</li> <li>defines the ARMv8 exception model, with four Exception levels, EL0-EL3, that provide an execution privilege hierarchy</li> <li>features 48-bit Virtual Address (VA), held in 64-bit registers. The Cortex-A57 MPCore multiprocessor VMSA maps these to 44-bit Physical Address (PA) maps</li> <li>defines a number of elements that hold the processor state (PSTATE). The A64 instruction set includes instructions that operate directly on various PSTATE elements</li> <li>names each System register using a suffix that indicates the lowest Exception level that the register can be accessed</li> </ul> </li> <li>AArch32 (backwards-compatible with implementations of the ARMv7-A architecture profile)<ul> <li>features 13 32-bit general purpose registers, and a 32-bit PC, SP, and Link Register (LR). Some of these registers have multiple Banked instances for use in different processor modes</li> <li>provides 32 64-bit registers for Advanced SIMD and Floating-point support</li> <li>provides two instruction sets, A32 and T32. For more information, see Instruction set state</li> <li>provides an exception model that maps the ARMv7 exception model onto the ARMv8 exception model and Exception levels</li> <li>features 32-bit VAs. The VMSA maps these to 40-bit PAs</li> <li>collects processor state into the Current Processor State Register (CPSR)</li> </ul> </li> </ol> <p>The processor can move between execution states only on a change of exception level. This change is also subject to certain rules.</p>"},{"location":"introduction/#exception-types","title":"Exception Types","text":""},{"location":"introduction/#synchronous-exceptions","title":"Synchronous Exceptions","text":"<p>Synchronous exceptions are exceptions that can be caused by, or are related to, the instruction that is currently being executed. Synchronous exceptions are synchronous to the execution stream, as they are directly related to the currently executing instruction.</p> <p>If the following all apply, then an exception is synchronous:</p> <ol> <li>The exception has been generated as a result of direct, or attempted, execution of an instruction.</li> <li>The address to return to once the exception has been handled (return address) has an architecturally-defined relationship with the instruction that caused the exception.</li> <li>The exception is precise, meaning the register state presented on entry to the exception handler is consistent with every instruction before the offending instruction having been executed, and none after it.</li> </ol> <p>There are many different types of synchronous exception, and it is possible that a given instruction might cause multiple synchronous exceptions. The Arm architecture provides a fixed priority order for synchronous exceptions. Some of the synchronous exception types are:</p> <ol> <li>Invalid instructions and trap exceptions</li> <li>Memory accesses</li> <li>Exception-generating instructions</li> <li>Debug exceptions</li> </ol> <p>Exception-generating instructions can be used to implement system call interfaces to allow less privileged software to request services from more privileged software. The Arm architecture includes the exception-generating instructions <code>SVC</code> (<code>EL0</code> -&gt; <code>EL1</code>), <code>HVC</code> (<code>EL1</code> -&gt; <code>EL2</code>), and <code>SMC</code> (<code>EL2</code> -&gt; <code>EL3</code>).</p>"},{"location":"introduction/#asynchronous-exceptions","title":"Asynchronous Exceptions","text":"<p>Asynchronous exceptions are not directly associated with the current executing instructions, and are typically system events from outside the processor. By definition, an exception is asynchronous if it is not synchronous. Asynchronous exceptions are also known as interrupts.</p> <p>Physical interrupts include:</p> <ol> <li>SError: intended to be generated by the memory system in response to unexpected events</li> <li>IRQ/FIQ: intended to be used to support handling of peripheral interrupts</li> <li>Virtual Interrupts: used for virtualization</li> </ol>"},{"location":"introduction/#handling-exceptions","title":"Handling Exceptions","text":""},{"location":"introduction/#general-information-on-handling-exceptions","title":"General Information on Handling Exceptions","text":"<p>In AArch64 specific terminology is used when talking about taking an exception:</p> <ul> <li>When the Processing Element (PE, usually a processor core) responds to an exception, an exception is\u00a2 taken.</li> <li>The PE state immediately before taking the exception is the state the exception is taken from.</li> <li>The PE state immediately after taking the exception is the state the exception is taken to.</li> </ul> <p>Example</p> <p>It is possible to take an exception from AArch32 EL0 to AArch64 EL1.</p> <p>After an exception has been handled, the system needs to return from the state it has been taken to. This is known as an Exception return, and the Arm architecture has instructions that trigger an Exception return:</p> <ul> <li>The state that the PE is in at the point the return instruction is executed is the state that the exception returns from.</li> <li>The PE state immediately after the exception return instruction has executed is the state that the exception returns to.</li> </ul>"},{"location":"introduction/#taking-an-exception","title":"Taking an Exception","text":"<p>When an exception occurs, the processor saves the current status of the PE alongside the exception return address, and then enters a specific mode to handle the exception. When an exception is taken to an Exception Level (<code>ELx</code>) that is using AArch64 state, all of the following occur:</p> <ul> <li>The contents of <code>PSTATE</code> immediately before the exception was taken is written to <code>SPSR_ELx</code>.</li> <li>The preferred exception return address is written to <code>ELR_ELx</code>.</li> <li>For synchronous exceptions and SError interrupts, exception syndrome information (the cause of the exception) is written to <code>ESR_ELx</code>.</li> <li>For address-related synchronous exceptions, such as MMU faults, the virtual address that triggered the exception is written to the Fault Address Register, <code>FAR_ELx</code>.</li> </ul> <p>Exception handling for any given exception starts from a fixed memory address called an exception vector. When an exception occurs the PE branches to a location in a vector table.</p> <p>Note</p> <p>Vector tables in AArch64 are different to many other processor architectures as they contain instructions, not addresses. Each entry contains up to 32 instructions ; just enough to perform basic stacking and call exception-specific handling code.</p> <p>Vector tables exists for every exception level (except for <code>EL0</code> of course), with the base address defined by its own Vector Base Address Register, <code>VBAR_ELx</code>.</p> <p>AArch64 has a concept of processor state known as <code>PSTATE</code> (on ARMv8 and later this is not a register), it is this information that is stored in the <code>%SPSR</code>. <code>PSTATE</code> contains things like current Exception level and Arithmetical Logical Unit (ALU) flags. In AArch64, this includes condition flags, execution state controls, exception mask bits, access control bits, timing control bits and speculation control bits.</p> <p>Tip</p> <p>The Arm Developer Documentation provides a page with examples when it comes to exception handling.</p>"},{"location":"introduction/#memory-management","title":"Memory Management","text":"<p>Definition: Memory Management</p> <p>Memory management describes how access to memory in a system is controlled. The hardware performs memory management every time that memory is accessed by either the OS or applications. Memory management is a way of dynamically allocating regions of memory to applications.</p> <p>Source</p> <p>The benefit of using virtual addresses is that it allows management software, such as an Operating System (OS), to control the view of memory that is presented to software. The OS can control what memory is visible, the virtual address at which that memory is visible, and what accesses are permitted to that memory. This allows the OS to sandbox applications (hiding the resources of one application from another application) and to provide abstraction from the underlying hardware.</p>"},{"location":"introduction/#address-spaces","title":"Address Spaces","text":""},{"location":"introduction/#virtual-address-spaces","title":"Virtual Address Spaces","text":"<p>There are several independent virtual address spaces in AArch64. Each of these virtual address spaces is independent, and has its own settings and (translation) tables. We often call these settings and tables \"translation regimes\". Because there are multiple virtual address spaces, it is important to specify which address space an address is in. For example, <code>NS.EL2:0x8000</code> refers to the address <code>0x8000</code> in the Non-secure EL2 virtual address space.</p>"},{"location":"introduction/#translation","title":"Translation","text":"<p>A virtual address must be translated to a physical address before a memory access can take place (because we must know which physical memory location we are accessing). This need for translation also applies to cached data, because on Armv6 and later processors, the data caches store data using the physical address (addresses that are physically tagged). Therefore, the address must be translated before a cache lookup can complete.</p>"},{"location":"introduction/#physical-addresses","title":"Physical Addresses","text":"<p>As well as multiple virtual address spaces (VAS), AArch64 also has multiple physical address spaces (PAS). Which physical address space, or spaces, a virtual address can be mapped to depends on the current Security state of the processor.</p>"},{"location":"introduction/#address-sizes","title":"Address Sizes","text":"<p>AArch64 is a 64-bit architecture, but this does not mean that all addresses are 64-bit.</p> <p>For virtual addresses, each region of address space has a size of up to 52-bits. The <code>TnSZ</code> fields in the <code>TCR_ELx</code> registers control the size of the virtual address space. The size of a physical address is implementation defined, up to a maximum of 52 bits.</p>"},{"location":"introduction/#address-space-identifiers","title":"Address Space Identifiers","text":"<p>Many modern OSs have applications that all seem to run from the same address region (user space). In practice, different applications require different mappings. This means, for example, that the translation for VA <code>0x8000</code> depends on which application is currently running.</p> <p>Ideally, we would like the translations for different applications to coexist within the Translation Lookaside Buffers (TLBs), to prevent the need for TLB invalidates on a context switch. But how would the processor know which version of the VA 0x8000 translation to use? In Armv8-A, the answer is Address Space Identifiers (ASIDs).</p> <p>For the EL0/EL1 virtual address space, translations can be marked as Global (G) or Non-Global (nG) using the nG bit in the attributes field of the translation table entry. For example, kernel mappings are Global translations, and application mappings are Non-Global translations. Global translations apply whichever application is currently running. Non-Global translations only apply with a specific application.</p> <p>Non-Global mappings are tagged with an ASID in the TLBs. On a TLB lookup, the ASID in the TLB entry is compared with the currently selected ASID. If they do not match, then the TLB entry is not used.</p>"},{"location":"introduction/#virtualization","title":"Virtualization","text":"<p>In virtualization, we call the set of translations that are controlled by the OS, Stage 1. The Stage 1 tables translate virtual addresses to intermediate physical addresses (IPAs). In Stage 1 the OS thinks that the IPAs are physical address spaces. However, the hypervisor controls a second set of translations, which we call Stage 2. This second set of translations translates IPAs to physical addresses.</p> <p>EL0/EL1 translations can also be tagged with a Virtual Machine Identifier (VMID). VMIDs allow translations from different VMs to coexist in the cache. This is similar to the way in which ASIDs work for translations from different applications. In practice, this means that some translations will be tagged with both a VMID and an ASID, and that both must match for the TLB entry to be used.</p>"},{"location":"introduction/#instruction-set-architecture-isa","title":"Instruction Set Architecture (ISA)","text":"<p>The Arm ISA allows you to write software and firmware that conforms to the Arm specifications. This mean that, if your software or firmware conforms to the specifications, any Arm-based processor will execute it in the same way.</p> <p>The 64-bit Armv8-A architecture, also known as AArch64, runs the A64 instruction set. All instructions are detailed in the Arm Architecture Reference Manual. Every Arm Architecture Reference Manual provides a detailed description of each instruction, including:</p> <ul> <li>Encoding - the representation of the instruction in memory.</li> <li>Arguments - inputs to the instruction.</li> <li>Pseudocode - what the instruction does, as expressed in Arm pseudocode language.</li> <li>Restrictions - when the instruction cannot be used, or the exceptions it can trigger.</li> </ul>"},{"location":"introduction/#sequential-execution-model","title":"Sequential Execution Model","text":"<p>The Arm architecture describes instructions following a Simple Sequential Execution (SSE) model. This means that the processor behaves as if the processor fetched, decoded and executed one instruction at a time, and in the order in which the instructions appeared in memory. In practice, modern processors have pipelines that can execute multiple instructions at once, and may do so out of order. This diagram shows an example pipeline for an Arm Cortex processor:</p> <p></p> <p>The architecture is a functional description. This means that it does not specify how an individual processor works. Each processor must behave consistently with the simple sequential execution model, even if it is reordering instructions internally.</p>"},{"location":"introduction/#registers","title":"Registers","text":""},{"location":"introduction/#general-purpose-registers","title":"General-Purpose Registers","text":"<p>The architecture provides 31 general purpose registers. Each register can be used as a 64-bit <code>X</code> (extended) register (<code>X0</code>..<code>X30</code>), or as a 32-bit <code>W</code> (word) register (<code>W0</code>..<code>W30</code>). When a <code>W</code> register is written, as seen in the example above, the top 32 bits of the 64-bit register are zeroed.</p> <p>There is a separate set of 32 registers used for floating point and vector operations. These registers are 128-bit, but like the general-purpose registers, can be accessed in several ways: <code>Bx</code> (byte) is 8 bits, <code>Hx</code> (halfword) is 16 bits, <code>Sx</code> (single) is 32 bits, <code>Dx</code> (double) is 64 bites and <code>Qx</code> (quad) which is 128 bits. These registers can also be referred to as <code>V</code> registers. When the <code>V</code> form is used, the register is treated as being a vector. This means that it is treated as though it contains multiple independent values, instead of a single value.</p>"},{"location":"introduction/#other-registers","title":"Other Registers","text":"<ul> <li>the zero registers, <code>XZR</code> and <code>WZR</code>, always read as 0 and ignore writes</li> <li><code>X30</code> is used as the Link Register and can be referred to as <code>LR</code>; separate registers, <code>ELR_ELx</code>, are used for returning from exceptions</li> <li>the Program Counter (<code>PC</code>) is not a general-purpose register in A64<ul> <li>it cannot be used with data processing instructions</li> <li>PC can be read using <code>ADR Xd, .</code></li> </ul> </li> <li>you can use the stack pointer (<code>SP</code>) as the base address for loads and stores<ul> <li>you can also use the stack pointer with a limited set of data-processing instructions, but it is not a regular general purpose register</li> <li>Armv8-A has multiple stack pointers, and each one is associated with a specific Exception level</li> <li>when SP is used in an instruction, it means the current stack pointer</li> </ul> </li> </ul> <p>Remember that in AArch64 the stack pointer (<code>SP</code>) must be 128-bit aligned!</p>"},{"location":"introduction/#system-registers","title":"System Registers","text":"<p>As well as general purpose registers, the architecture defines system registers. System registers are used to configure the processor and to control systems such as the MMU and exception handling. System registers cannot be used directly by data processing or load/store instructions. Instead, the contents of a system register need to be read into an X register, operated on, and then written back to the system register. There are two specialist instructions for accessing system registers:</p> <pre><code># read the system register into Xd\nMRS Xd, &lt;system register&gt;\n\n# write Xn to the system regsiter\nMSR &lt;system register&gt;, Xn\n\n# System registers are specified by name:\n# read SCTLR_EL1 into X0\nMRS X0, SCTLR_EL1\n</code></pre> <p>System register names end with <code>_ELx</code> which specifies the minimum privilege necessary to access the register.</p> <p>Note</p> <p>Sometimes you will see <code>_EL12</code> or <code>_EL01</code>. These are used as part of virtualization. Refer to the guide on virtualization for more information.</p>"},{"location":"introduction/#instructions","title":"Instructions","text":""},{"location":"introduction/#data-processing","title":"Data Processing","text":"<p>Assembly instructions follow a basic format:</p> <pre><code>&lt;SYMBOL&gt;:\n(F)&lt;OPARATION&gt;(S) &lt;DESTINATION REGISTER&gt;, &lt;INPUT REGISTER&gt;, &lt;INPUT REGISTER or CONSTANT&gt;  (, &lt;INPUT REGISTER&gt;) (, &lt;EXTRA FLAGS&gt;)\n</code></pre> <ul> <li>an <code>F</code> can be prepended to the opration to use floating point operations (and operands)</li> <li>an <code>S</code> can be appended to the operation to set flags (e.g., for the ALU)</li> <li>adding extra flags (like <code>SXTH</code> (sign-extend) to <code>ADD</code>) will cause the instruction to behave slightly differently</li> <li>DESTINATION is always a register</li> <li>operand 1 will always be a register</li> </ul> <p>There are some special instructions:</p> <ol> <li><code>MOV</code> moves a constant, or the contents of another register, into the register specified as the destination</li> <li><code>MVN</code> is like a copy, but \"negative\"</li> </ol>"},{"location":"introduction/#loads-stores","title":"Loads &amp; Stores","text":""},{"location":"introduction/#general-information-on-loads-stores","title":"General Information on Loads &amp; Stores","text":"<p>The basic load and store operations are: <code>LDR</code> (load) and <code>STR</code> (store). These operations transfer a single value between memory and the general-purpose registers. The syntax for these instructions is:</p> <pre><code>LDR&lt;Sign&gt;&lt;Size&gt;    &lt;Destination&gt;, [&lt;address&gt;]\nSTR&lt;Size&gt;          &lt;Destination&gt;, [&lt;address&gt;]\n</code></pre> <p>The size of the load or store is determined by the register type <code>X</code> or <code>W</code> and the Size field. With <code>S</code>, the value is sign-extended to the register size chosen.</p>"},{"location":"introduction/#addressing","title":"Addressing","text":"<p>There are several addressing modes that define how the address is formed.</p> <ol> <li>Base Register<ul> <li>the simplest form of addressing is a single register</li> <li>the base register is an <code>X</code> register that contains the full, or absolute, virtual address of the data being accessed</li> <li>example: <code>LDRR W0, [X1]</code></li> </ul> </li> <li>Offset Addressing<ul> <li>like 1., but an offset can be applied optionally to the base address</li> <li>example: <code>LDR W0, [X1, #12]</code></li> <li>the offset can be either a constant or another register</li> <li>might be used for <code>struct</code>s</li> </ul> </li> <li>Pre-Index Addressing<ul> <li>like offset addressing, except that the base pointer is updated as a result of the instruction</li> <li>example: <code>LDR W0, [X1, #12]!</code> (this is like <code>LDR W0, [X1, #12] ; ADD X1, X1, #12 ;</code>)</li> </ul> </li> <li>Post-Index Addressing<ul> <li>value is loaded from the address in the base pointer, and then the pointer is updated</li> <li>example: <code>LDR W0, [X1], #12</code> (this is like <code>LDR W0, [X1] ; ADD X1, X1, #12 ;</code>)</li> <li>useful for popping off the stack</li> </ul> </li> </ol>"},{"location":"introduction/#using-pairs","title":"Using Pairs","text":"<p>A64 also has load (<code>LDP</code>) and store pair (<code>STP</code>) instructions. These pair instructions transfer two registers to and from memory. Load and store pair instructions are often used for pushing, and popping off the stack.</p> Example <p>This instruction loads <code>[X0]</code> into <code>W3</code>, and loads <code>[X0 + 4]</code> into <code>W7</code>:</p> <pre><code>LDP   W3, W7, [X0]\n</code></pre> <p>This instruction pushes <code>X0</code> and <code>X1</code> onto the stack (<code>#-16</code> is the immediate value -16):</p> <pre><code>STP   X0, X1, [SP, #-16]!\n</code></pre>"},{"location":"introduction/#specialist-instructions","title":"Specialist Instructions","text":"<p>These are load and stores instructions with implicit memory barriers. Armv8.7-A and Armv9.2-A add support for a 64-byte atomic load (<code>LD64B</code>) instruction and three store (<code>ST64Bx</code>) instructions are added to the architecture.</p> <p>The <code>memcpy()</code>/<code>memset()</code> family of functions are widely used across many workloads. It is therefore important that they run as efficiently as possible. To enable a standard optimized implementation of these functions, which will be efficient across different processor implementations, A64 includes the <code>CPYx</code> and <code>SETx</code> instructions.</p>"},{"location":"introduction/#program-flow","title":"Program Flow","text":"<p>Ordinarily, a processor executes instructions in program order. This means that a processor executes instructions in the same order that they are set in memory. One way to change this order is to use branch instructions. Branch instructions change the program flow and are used for loops, decisions and function calls.</p> <p>The A64 instruction set also has some conditional branch instructions. These are instructions that change the way they execute, based on the results of previous instructions.</p> <p>Tip</p> <p>Armv8.3-A and Armv8.5-A introduced instructions to protect against return-oriented programming and jump-oriented programming.</p>"},{"location":"introduction/#loops-decisions","title":"Loops &amp; Decisions","text":"<p>There are two types of branch instructions: unconditional and conditional.</p>"},{"location":"introduction/#unconditional-branch-instructions","title":"Unconditional Branch Instructions","text":"<p>There are two types of unconditional branch instructions:</p> <ol> <li><code>B &lt;label&gt;</code> which means Branch<ul> <li>performs a direct, PC-relative, branch to <code>&lt;label&gt;</code></li> <li>offset from the current PC to the destination is encoded within the instruction</li> <li>range is limited by the space available within the instruction to record the offset and is +/-128MB</li> </ul> </li> <li><code>BR &lt;Xn&gt;</code> which means Branch with Register<ul> <li>performs an indirect, or absolute, branch to the address specified in <code>Xn</code></li> </ul> </li> </ol>"},{"location":"introduction/#conditional-branch-instructions","title":"Conditional Branch Instructions","text":"<p>The conditional branch instruction <code>&lt;x&gt;B.&lt;cond&gt; &lt;label&gt;</code> is the conditional version of the <code>B</code> instruction. The branch is only taken if the condition <code>&lt;cond&gt;</code> is true. The range is limited to +/-1MB. The condition is tested against the ALU flags stored in <code>PSTATE</code> and needs to be generated by a previous instruction such as a compare (<code>CMP</code>).</p>"},{"location":"introduction/#generating-condition-code-conditional-selects","title":"Generating Condition Code &amp; Conditional Selects","text":"<p>ALU flags are set as a side effect of data-processing instructions. To recap, an <code>S</code> at the end of <code>&lt;OPERATION&gt;</code> causes the ALU flags to be updated. ALU flags are: <code>N</code> for negative, <code>C</code> for carry, <code>V</code> for overflow and <code>Z</code> for zero. For example, the condition code (<code>&lt;cond&gt;</code>) for equal (<code>EQ</code>) check for <code>Z==1</code>.</p> <p>In addition to the regular data-processing instructions, other instructions are available that only update the ALU flags:</p> <pre><code># compare, an alias of SUBS XZR, X0, X7\nCMP X0, X7\n# test, an alias of ANDS WZR, W5, #1\nTST W5, #1\n</code></pre> <p>So far, we have seen examples that use branches to handle decisions. The A64 instruction set also provides conditional select instructions. In many cases, these instructions can be used as an alternative to branches. There are many variants, but the basic form is:</p> <pre><code>CSEL Xd, Xn, Xm, cond\n</code></pre> <p>Tip</p> <p>Importantly, conditional selects also remove the need to branch. In modern processors, this kind of branch can be difficult for the branch prediction logic to predict correctly. A mispredicted branch can have a negative effect on performance, it is better that you remove branches where possible.</p>"},{"location":"introduction/#function-calls","title":"Function Calls","text":"<p>When calling a function or sub-routine, we need a way to get back to the caller when finished. Adding an <code>L</code> to the <code>B</code> or <code>BR</code> instructions turns them into a branch with link. This means that a return address is written into <code>LR</code> (the link register, i.e. <code>X30</code>) as part of the branch.</p> <p>There is a specialist function return instruction, <code>RET</code>. This performs an indirect branch to the address in the link register.</p> Direct vs Indirect Branching <p>Direct branch (DB) is an instruction which explicitly includes the jump destination address (in full, or as an offset from a register) in the body of the instruction. An indirect branch (IB) is an instruction that includes a pointer to a memory address, which in turn contains the jump destination address.</p> Why Do We Need <code>RET</code>? <p>Why do we need a special function return instruction? Functionally, BR LR would do the same job as RET. Using RET tells the processor that this is a function return. Most modern processors, and all Cortex-A processors, support branch prediction. Knowing that this is a function return allows processors to more accurately predict the branch.</p> <p>A function call might then look like this:</p> <pre><code>.type foo, @function\nbar:\nBL foo # call function foo\n...\n\n.global foo\n.type foo, @function\nfoo:\n...\nRET\n</code></pre>"},{"location":"introduction/#procedure-call-standards","title":"Procedure Call Standards","text":"<p>The Arm architecture places few restrictions on how general purpose registers are used. To recap, integer registers and floating-point registers are general purpose registers. However, if you want your code to interact with code that is written by someone else, or with code that is produced by a compiler, then you need to agree rules for register usage. For the Arm architecture, these rules are called the Procedure Call Standard, or PCS. This is commonly also known as \"calling convention\", required for ABI compliance.</p> <p>The PCS says that the first argument is passed in X0, the second argument in X1, and so on up to X7. Any further arguments are passed on the stack. Here is the table that shows caller- and callee-saved registers:</p> <code>X0</code> - <code>X7</code> <code>X8</code> - <code>X15</code> <code>X16</code> - <code>X23</code> <code>X24</code> - <code>X30</code> Parameter and Result Registers (<code>X0</code> - <code>X7</code>) <code>XR</code> (<code>X8</code>) <code>IP0</code> (<code>X16</code>) Callee-saved Registers (<code>X24</code> - <code>X28</code>) Corruptible Registers (<code>X9</code> - <code>X15</code>) <code>IP1</code> (<code>X17</code>) <code>FP</code> (<code>X29</code>) <code>PR</code> (<code>X18</code>) <code>LR</code> (<code>X30</code>) Callee-Saved Registers (<code>X19</code> - <code>X23</code>) Some Registers Have Special Significance in the PCS <ul> <li><code>XR</code>: indirect result register<ul> <li>if <code>foo()</code> returned a <code>struct</code>, then the memory for <code>struct</code> would be allocated by the caller (<code>main()</code>)</li> <li><code>XR</code> is a pointer to the memory allocated by the caller for returning the <code>struct</code></li> </ul> </li> <li><code>IP0</code> and <code>IP1</code>: intra-procedure-call corruptible registers<ul> <li>can be corrupted between the time that the function is called and the time that it arrives at the first instruction in the function</li> <li>used by linkers to insert veneers between the caller and callee</li> <li>veneers = small pieces of code; most common example is for branch range extension: the branch instruction in A64 has a limited range, if the target is beyond that range, then the linker needs to generate a veneer to extend the range of the branch</li> </ul> </li> <li><code>FP</code>: frame pointer</li> <li><code>LR</code> (= <code>X30</code>): link register for function calls</li> </ul> <p>The PCS says that the ALU flags do not need to be preserved across a function call.</p> Floating Point Registers <code>D0</code> - <code>D7</code> <code>D8</code> - <code>D15</code> <code>D16</code> - <code>D23</code> <code>D24</code> - <code>D31</code> Parameter and Result Registers (<code>D0</code> - <code>D7</code>) Callee-saved Registers (<code>D8</code> - <code>D15</code>) Callee-saved Registers (<code>D16</code> - <code>D31</code>) Callee-saved Registers (<code>D16</code> - <code>D31</code>)"},{"location":"sources/","title":"Sources","text":""},{"location":"sources/#more-about-arm","title":"More About Arm","text":"<p>Each Arm</p> <ul> <li>Architecture Reference Manual describes an architecture specification. An Arm Architecture Reference Manual is relevant to any implementation of that architecture.</li> <li>Cortex processor has a Technical Reference Manual (TRM). A TRM describes the features specific to that processor. In general, TRMs do not repeat any information given in the Arm Architecture Reference Manuals.</li> <li>Cortex processor also has a Configuration and Integration Manual (CIM). The CIM describes how to integrate the processor into a system. Generally, this information is only relevant to SoC designers.</li> </ul>"},{"location":"sources/#general","title":"General","text":"<p>This documentation is a \"meta-documentation\" as it is based on other documentations and sources.</p> <ol> <li>Ask development questions and find articles and blogs on specific topics from Arm experts</li> <li>Arm Architecture and Processor Manuals</li> <li>Arm Docs (LtA) - Introducing the Arm Architecture</li> <li>Arm Docs (LtA) - Guides</li> <li>Arm Docs (LtA) - Exception Model</li> <li>Arm Docs (LtA) - AArch64 Virtualization</li> <li>Arm Docs (LtA) - TrustZone for AArch64</li> <li>Arm Docs (LtA) - Memory Management</li> <li>Arm Docs (LtA) - ISA</li> </ol>"},{"location":"hardware/","title":"Hardware","text":"<p>Work In Progress</p> <p>This chapter has not yet been started.</p>"},{"location":"hardware/registers/","title":"Registers","text":""},{"location":"virtualization/","title":"Virtualization","text":"<p>Work In Progress</p> <p>This chapter has not yet been started.</p>"}]}